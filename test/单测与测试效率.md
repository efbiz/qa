## 短链测试与长链测试<br/>
如果存在一种方法，能够不费事地很快检测出系统中的代码问题，那么何乐而不为呢？单测正是这样一种测试方法。
测试可分为“短链测试”和“长链测试”。其中短链测试不需要依赖外部服务，仅对短小的一段代码进行测试，写完后几乎不需要准备就能立即运行完成，而且当运行出错时，几乎可以很快定位出问题的位置；长链测试则在写完后需要花费时间来准备数据、环境和外部服务，运行时间更长，而且运行出错时，往往要花更多时间来进行调试。
单测是一种短链测试，而接口测试则是一种长链测试。显然，如果单测覆盖得越密集，那么就能更快速有效地覆盖到更多代码； 因此，优先推荐编写单测而非接口测试。
## 单测与接口测试的平衡<br/>
过犹不及。并不是越多单测效果就越好。当单测密集度达到一定程度时，所起的质量检测效果就会趋于平缓。
这是由于：
(1) 依赖外部服务或组件的完整流程是单测难以覆盖的；
(2) 性能和累积性问题是单测无法覆盖的；
(3) 有些情况下，一个接口测试可以起到十个单测的作用。 因此，适当地使用接口测试作为单测的补充，是非常重要的。
一般来说，单测用于密集覆盖条件分支和循环分支，而接口测试用于覆盖顺序流程和完整流程。
## 单测与动态语言<br/>
通常选择动态语言能够更加便捷地编写测试。以下代码是用Groovy编写一段接口测试:
<code><br/>
// 测试主要的订单搜索接口 当查询起始结束时间间隔超过3个月时, 抛出异常<br/>
  @Test
  public void testGetOrderList3MonthLimitExceed() {<br/>
        // 超过三个月间隔的不同情况
        def invalidTimeParamsList = [<br/>
            ['start_time': -34500, 'end_time': 1476152571],<br/>
            ['start_time': 1476152571 - threeMonthSeconds-1, 'end_time': 1476152571],<br/>
            ['start_time': TimeUtils.currTimeWithSecond() - threeMonthSeconds-1],<br/>
            ['end_time': TimeUtils.currTimeWithSecond() + threeMonthSeconds+8]<br/>
        ]<br/>
        def paramsOfInterfaces = [<br/>
                "biz.xxx.list.get": [[]],<br/>
                "biz.xxx.List.gift": [["type": "gift"]],<br/>
                "biz.xxx.List.tuan": [["t_id": "1111234567890000"]],<br/>
                "biz.xxx.yyy.getOrderBySearch": [["phone": "15211111111"], ["name": "qin"], ["g_id": "271111"]]<br/>
        ]
        // 第一层循环: 设置不同的不合法时间参数<br/>
        // 第二层循环: 设置不同的查询条件以调用不同的查询接口<br/>
        invalidTimeParamsList.each { <br/>
           invalidTimeParams -><br/>
            paramsOfInterfaces.each {<br/>
               interfaceName, queryParamsList -><br/>
                queryParamsList.each { queryParams -><br/>
                    def params = createBaseParam()<br/>
                    params.putAll(invalidTimeParams)<br/>
                    params.putAll(queryParams)<br/>
                    try {<br/>
                        RPClientUtil.call(interfaceName, params, new Object(), true)<br/>
                        fail(NOT_THROW_EXCEPTION)<br/>
                    } catch (BaseException be) {<br/>
                        assertEquals("100001", be.getReturnCode())<br/>
                        assertEquals("每次可搜索3个月订单记录，请重新选择起止时间.",<br/> be.getReturnMessage())<br/>
                    }
                }
            }
        }
    }
</code><br/>
可以看到，动态语言更好地支持 Map, List 等常见容器的简洁语法，更容易操控。
